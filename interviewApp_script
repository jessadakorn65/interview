/** =========================
 *  CONFIG
 *  ========================= */
const SPREADSHEET_ID = "1ozLZm32sh2VNe0N2PTgFFDLcdZ4kEW7UDhaGCFnLgEc";
const SHEET_NAME = "raw";

// หน่วงเวลาเขียนกันชน (ms) — ปรับได้ เช่น 200-800
const WRITE_DELAY_MS = 500;
const LAST_WRITE_TS_KEY = "LAST_WRITE_TS_V1";

// LOG (ปิดได้)
const LOG_SHEET_NAME = "LOG";
const ENABLE_SHEET_LOG = true;

/** =========================
 *  RAW headers (ตามชีตของคุณ)
 *  ========================= */
const COL_ID = "ID";
const COL_FINAL = "/Final";
const COL_TITLE = "/TitleName";
const COL_THAI_NAME = "/Name(Thai)";
const COL_THAI_SURNAME = "/surname(Thai)";
const COL_ENG_NAME = "/Name(English)";
const COL_ENG_SURNAME = "/surname(English)";
const COL_PIC = "/pic";
const COL_BIRTH_RAW = "/birth";
const COL_BIRTH_DMY = "/birth(DD/MM/YYYY)";
const COL_STATUS = "/Status/";
const COL_COMMENT = "/Comment/";
const COL_TS_DEPA = "/TimestampDepa/";
const COL_UNIVERSITY = "University";

/** =========================
 *  ✅ Header normalize / alias helpers
 * ========================= */
function normHeader_(s) {
  return String(s ?? "")
    .trim()
    .replace(/\s+/g, "")          // remove spaces
    .replace(/^\/+|\/+$/g, "")    // strip leading/trailing /
    .toLowerCase();
}

function buildColIndex_(header) {
  const idx = {};
  header.forEach((h, i) => {
    const k = normHeader_(h);
    if (k && idx[k] == null) idx[k] = i;
  });
  return idx;
}

function getIdxByAliases_(colIndexNorm, aliases) {
  for (const a of aliases) {
    const k = normHeader_(a);
    if (colIndexNorm[k] != null) return colIndexNorm[k];
  }
  return null;
}

/** =========================
 *  WEB APP ENTRY
 * ========================= */
function doGet(e) {
  const action = String(e?.parameter?.action || "").toLowerCase();
  if (!action) return jsonOut_({ ok: true, msg: "API running. Use ?action=export|search|update|status" });

  try {
    if (action === "export") {
      const limit = Number(e.parameter.limit || "0") || 0;
      const rows = exportAll_(limit);
      return jsonOut_({ ok: true, rows });
    }

    if (action === "search") {
      const id = String(e.parameter.id || "").trim();
      if (!id) return jsonOut_({ ok: false, error: "missing id" });
      const data = searchByIdOrFinal_(id);
      return jsonOut_({ ok: true, data: data || null });
    }

    if (action === "update") {
      const id = String(e.parameter.id || "").trim();
      const status = String(e.parameter.status || "").trim();
      const comment = String(e.parameter.comment || "");

      if (!id || !status) return jsonOut_({ ok: false, error: "missing id/status" });

      const res = updateStatusByIdOrFinal_(id, status, comment);
      if (!res.updated) {
        log_("WARN", "update failed", res);
        return jsonOut_({ ok: false, ...res });
      }
      return jsonOut_({ ok: true, ...res });
    }

    if (action === "status") {
      return jsonOut_({ ok: true, writeDelayMs: WRITE_DELAY_MS });
    }

    return jsonOut_({ ok: false, error: "unknown action: " + action });
  } catch (err) {
    log_("ERROR", "doGet exception", { error: err.message, action });
    return jsonOut_({ ok: false, error: "Exception: " + err.message });
  }
}

/** =========================
 *  Sheet helpers
 *  ========================= */
function getSheet_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) throw new Error("Sheet tab not found: " + SHEET_NAME);
  return sh;
}

function readHeader_(sh) {
  const lastCol = sh.getLastColumn();
  const header = sh.getRange(1, 1, 1, lastCol).getValues()[0].map(x => String(x).trim());
  const colIndexNorm = buildColIndex_(header);
  return { header, colIndexNorm, lastCol };
}

function ensureCols_(sh, colIndexNorm, lastCol) {
  // เพิ่มคอลัมน์เฉพาะกรณี "ไม่มีจริง ๆ" (ทั้งแบบมี/ไม่มี /)
  const need = [
    { name: COL_STATUS, aliases: [COL_STATUS, "Status"] },
    { name: COL_COMMENT, aliases: [COL_COMMENT, "Comment"] },
    { name: COL_TS_DEPA, aliases: [COL_TS_DEPA, "TimestampDepa", "Timestamp"] },
    { name: COL_UNIVERSITY, aliases: [COL_UNIVERSITY, "University"] },
  ];

  let added = 0;
  for (const it of need) {
    const found = getIdxByAliases_(colIndexNorm, it.aliases);
    if (found == null) {
      sh.getRange(1, lastCol + 1 + added).setValue(it.name);
      colIndexNorm[normHeader_(it.name)] = lastCol + added;
      added++;
    }
  }
  return sh.getLastColumn();
}

/** =========================
 *  Throttle + Lock
 *  ========================= */
function lockAndThrottle_() {
  const lock = LockService.getScriptLock();
  lock.waitLock(25000);
  try {
    const props = PropertiesService.getScriptProperties();
    const last = Number(props.getProperty(LAST_WRITE_TS_KEY) || "0");
    const now = Date.now();
    const wait = (last + WRITE_DELAY_MS) - now;
    if (wait > 0) Utilities.sleep(wait);

    props.setProperty(LAST_WRITE_TS_KEY, String(Date.now()));
    return lock;
  } catch (e) {
    lock.releaseLock();
    throw e;
  }
}

/** =========================
 *  Image Normalizer
 *  ========================= */
function normalizeImage_(v) {
  if (v == null) return { imageUrl: "", fallbackUrl: "", fileId: "", raw: "" };

  if (Array.isArray(v)) v = v[0];
  if (typeof v === "object") {
    for (const k of ["url","link","src","fileUrl","downloadUrl","id","fileId","imageUrl"]) {
      if (v && v[k]) return normalizeImage_(v[k]);
    }
    return { imageUrl: "", fallbackUrl: "", fileId: "", raw: "" };
  }

  let s = String(v).trim();
  if (!s) return { imageUrl: "", fallbackUrl: "", fileId: "", raw: "" };

  if ((s.startsWith("{") && s.endsWith("}")) || (s.startsWith("[") && s.endsWith("]"))) {
    try { return normalizeImage_(JSON.parse(s)); } catch (e) {}
  }

  if (s.includes(",")) s = s.split(",")[0].trim();

  if (/^data:image\/[a-zA-Z0-9.+-]+;base64,/.test(s)) {
    return { imageUrl: s, fallbackUrl: "", fileId: "", raw: s };
  }

  const fileId = extractDriveFileIdSafe_(s);
  if (fileId) {
    return {
      raw: s,
      fileId,
      imageUrl: `https://drive.google.com/thumbnail?id=${fileId}&sz=w800`,
      fallbackUrl: `https://drive.google.com/uc?export=view&id=${fileId}`
    };
  }

  if (/^https?:\/\//i.test(s)) return { imageUrl: s, fallbackUrl: "", fileId: "", raw: s };
  return { imageUrl: s, fallbackUrl: "", fileId: "", raw: s };
}

function extractDriveFileIdSafe_(urlOrId) {
  const s = String(urlOrId || "").trim();
  if (!s) return "";
  if (/^[a-zA-Z0-9_-]{20,}$/.test(s)) return s;

  let m = s.match(/\/d\/([a-zA-Z0-9_-]{10,})/);
  if (m) return m[1];

  m = s.match(/[?&]id=([a-zA-Z0-9_-]{10,})/);
  if (m) return m[1];

  m = s.match(/open\?id=([a-zA-Z0-9_-]{10,})/);
  if (m) return m[1];

  return "";
}

/** =========================
 *  Mapper: row -> profile object (alias-safe)
 *  ========================= */
function mapProfileFromRow_(header, row) {
  const m = {};
  for (let i = 0; i < header.length; i++) {
    m[normHeader_(header[i])] = row[i];
  }

  const getV_ = (aliases) => {
    for (const a of aliases) {
      const v = m[normHeader_(a)];
      if (v !== undefined) return v;
    }
    return "";
  };

  const picVal = getV_([COL_PIC, "pic"]);
  const img = (picVal != null && String(picVal).trim() !== "") ? normalizeImage_(picVal) : null;

  return {
    ID: String(getV_([COL_ID, "ID"]) ?? "").trim(),
    Final: getV_([COL_FINAL, "Final"]),
    TitleName: getV_([COL_TITLE, "TitleName"]),

    ThaiFirstname: getV_([COL_THAI_NAME, "Name(Thai)", "NameThai"]),
    ThaiLastname: getV_([COL_THAI_SURNAME, "surname(Thai)", "Surname(Thai)", "SurnameThai"]),

    EnglishFirstname: getV_([COL_ENG_NAME, "Name(English)", "NameEnglish", "EnglishFirstname"]),
    EnglishLastname: getV_([COL_ENG_SURNAME, "surname(English)", "Surname(English)", "SurnameEnglish", "EnglishLastname"]),

    Birth: getV_([COL_BIRTH_RAW, "birth", "Birth"]),
    Birth_DDMMYYYY: getV_([COL_BIRTH_DMY, "birth(DD/MM/YYYY)", "Birth(DD/MM/YYYY)"]),

    Image: img ? (img.imageUrl || "") : "",
    ImageFallback: img ? (img.fallbackUrl || "") : "",
    ImageFileId: img ? (img.fileId || "") : "",

    Status: getV_([COL_STATUS, "Status"]),
    Comment: getV_([COL_COMMENT, "Comment"]),
    TimestampDepa: getV_([COL_TS_DEPA, "TimestampDepa"]),
    University: getV_([COL_UNIVERSITY, "University"])
  };
}

/** =========================
 *  API functions
 *  ========================= */
function searchByIdOrFinal_(key) {
  const sh = getSheet_();
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return null;

  let { header, colIndexNorm, lastCol } = readHeader_(sh);
  const newLastCol = ensureCols_(sh, colIndexNorm, lastCol);
  if (newLastCol !== lastCol) ({ header, colIndexNorm } = readHeader_(sh));

  const allCol = sh.getLastColumn();
  const values = sh.getRange(2, 1, lastRow - 1, allCol).getValues();

  const idIdx = getIdxByAliases_(colIndexNorm, [COL_ID, "ID"]);
  const finalIdx = getIdxByAliases_(colIndexNorm, [COL_FINAL, "Final"]);
  if (idIdx == null && finalIdx == null) throw new Error("Missing ID/Final columns");

  const k = String(key || "").trim();
  let ridx = -1;

  for (let r = 0; r < values.length; r++) {
    if (idIdx != null && String(values[r][idIdx] ?? "").trim() === k) { ridx = r; break; }
    if (finalIdx != null && String(values[r][finalIdx] ?? "").trim() === k) { ridx = r; break; }
  }
  if (ridx < 0) return null;

  return mapProfileFromRow_(header, values[ridx]);
}

function exportAll_(limit) {
  const sh = getSheet_();
  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastRow < 2) return [];

  const header = sh.getRange(1, 1, 1, lastCol).getValues()[0].map(x => String(x).trim());
  const values = sh.getRange(2, 1, lastRow - 1, lastCol).getValues();

  const out = [];
  const n = Math.min(values.length, (limit && limit > 0) ? limit : values.length);
  for (let r = 0; r < n; r++) out.push(mapProfileFromRow_(header, values[r]));
  return out;
}

function updateStatusByIdOrFinal_(key, status, comment) {
  const lock = lockAndThrottle_();
  try {
    const sh = getSheet_();
    const lastRow = sh.getLastRow();
    if (lastRow < 2) return { updated: false, error: "no data rows" };

    let { header, colIndexNorm, lastCol } = readHeader_(sh);
    ensureCols_(sh, colIndexNorm, lastCol);
    ({ header, colIndexNorm } = readHeader_(sh));

    const allCol = sh.getLastColumn();
    const values = sh.getRange(2, 1, lastRow - 1, allCol).getValues();

    const idIdx = getIdxByAliases_(colIndexNorm, [COL_ID, "ID"]);
    const finalIdx = getIdxByAliases_(colIndexNorm, [COL_FINAL, "Final"]);

    const statusIdx = getIdxByAliases_(colIndexNorm, [COL_STATUS, "Status"]);
    const commentIdx = getIdxByAliases_(colIndexNorm, [COL_COMMENT, "Comment"]);
    const tsIdx = getIdxByAliases_(colIndexNorm, [COL_TS_DEPA, "TimestampDepa"]);

    const k = String(key || "").trim();
    let ridx = -1;

    for (let r = 0; r < values.length; r++) {
      if (idIdx != null && String(values[r][idIdx] ?? "").trim() === k) { ridx = r; break; }
      if (finalIdx != null && String(values[r][finalIdx] ?? "").trim() === k) { ridx = r; break; }
    }
    if (ridx < 0) return { updated: false, error: "id/final not found", id: String(key) };

    values[ridx][statusIdx] = String(status ?? "");
    values[ridx][commentIdx] = String(comment ?? "");
    values[ridx][tsIdx] = new Date();

    sh.getRange(2, 1, values.length, allCol).setValues(values);

    return { updated: true, id: String(key) };
  } finally {
    lock.releaseLock();
  }
}

/** =========================
 *  OUTPUT
 * ========================= */
function jsonOut_(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

/** =========================
 *  LOG
 * ========================= */
function getLogSheet_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh = ss.getSheetByName(LOG_SHEET_NAME);
  if (!sh) {
    sh = ss.insertSheet(LOG_SHEET_NAME);
    sh.appendRow(["Timestamp", "Level", "Message", "Payload(JSON)"]);
  }
  return sh;
}

function log_(level, message, payload) {
  const ts = new Date();
  const p = payload ? JSON.stringify(payload) : "";
  Logger.log(`[${level}] ${message} ${p}`);
  if (ENABLE_SHEET_LOG) {
    try { getLogSheet_().appendRow([ts, level, message, p]); }
    catch (e) { Logger.log(`[ERROR] write log sheet failed: ${e.message}`); }
  }
}
